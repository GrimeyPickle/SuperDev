<div class="py-16 sm:py-20 lg:py-24 bg-white sm:bg-secondary">
	<div class="innerDivTwo">
		<div class="rounded-2xl overflow-hidden bg-transparent sm:bg-white">
			<div class="mx-0 my-0 sm:mx-12 sm:my-12">
				<span
					style="
						box-sizing: border-box;
						display: inline-block;
						overflow: hidden;
						width: initial;
						height: initial;
						background: none;
						opacity: 1;
						border: 0px;
						margin: 0px;
						padding: 0px;
						position: relative;
						max-width: 100%;
						--darkreader-inline-bgimage: none;
						--darkreader-inline-bgcolor: initial;
						--darkreader-inline-border-top: initial;
						--darkreader-inline-border-right: initial;
						--darkreader-inline-border-bottom: initial;
						--darkreader-inline-border-left: initial;
					"
					data-darkreader-inline-bgimage=""
					data-darkreader-inline-bgcolor=""
					data-darkreader-inline-border-top=""
					data-darkreader-inline-border-right=""
					data-darkreader-inline-border-bottom=""
					data-darkreader-inline-border-left=""
					><span
						style="
							box-sizing: border-box;
							display: block;
							width: initial;
							height: initial;
							background: none;
							opacity: 1;
							border: 0px;
							margin: 0px;
							padding: 0px;
							max-width: 100%;
							--darkreader-inline-bgimage: none;
							--darkreader-inline-bgcolor: initial;
							--darkreader-inline-border-top: initial;
							--darkreader-inline-border-right: initial;
							--darkreader-inline-border-bottom: initial;
							--darkreader-inline-border-left: initial;
						"
						data-darkreader-inline-bgimage=""
						data-darkreader-inline-bgcolor=""
						data-darkreader-inline-border-top=""
						data-darkreader-inline-border-right=""
						data-darkreader-inline-border-bottom=""
						data-darkreader-inline-border-left=""
						><img
							alt=""
							aria-hidden="true"
							src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27984%27%20height=%27623%27/%3e"
							style="
								display: block;
								max-width: 100%;
								width: initial;
								height: initial;
								background: none;
								opacity: 1;
								border: 0px;
								margin: 0px;
								padding: 0px;
								--darkreader-inline-bgimage: none;
								--darkreader-inline-bgcolor: initial;
								--darkreader-inline-border-top: initial;
								--darkreader-inline-border-right: initial;
								--darkreader-inline-border-bottom: initial;
								--darkreader-inline-border-left: initial;
							"
							data-darkreader-inline-bgimage=""
							data-darkreader-inline-bgcolor=""
							data-darkreader-inline-border-top=""
							data-darkreader-inline-border-right=""
							data-darkreader-inline-border-bottom=""
							data-darkreader-inline-border-left="" /></span
					><img
						alt="Fast Loading Website"
						srcset="
							/_next/image?url=%2Fblog%2Ffast-loading-website.jpg&amp;w=1080&amp;q=75 1x,
							/_next/image?url=%2Fblog%2Ffast-loading-website.jpg&amp;w=2048&amp;q=75 2x
						"
						src="/_next/image?url=%2Fblog%2Ffast-loading-website.jpg&amp;w=2048&amp;q=75"
						decoding="async"
						data-nimg="intrinsic"
						class="w-full rounded-2xl"
						style="
							position: absolute;
							inset: 0px;
							box-sizing: border-box;
							padding: 0px;
							border: none;
							margin: auto;
							display: block;
							width: 0px;
							height: 0px;
							min-width: 100%;
							max-width: 100%;
							min-height: 100%;
							max-height: 100%;
							--darkreader-inline-border-top: initial;
							--darkreader-inline-border-right: initial;
							--darkreader-inline-border-bottom: initial;
							--darkreader-inline-border-left: initial;
						"
						data-darkreader-inline-border-top=""
						data-darkreader-inline-border-right=""
						data-darkreader-inline-border-bottom=""
						data-darkreader-inline-border-left=""
				/></span>
				<h1 class="text-gray-800 font-medium text-2xl sm:text-3xl leading-snug sm:leading-snug my-8">
					How our websites load under one second around the globe?
				</h1>
				<section>
					<p class="text-gray-700 text-lg font-light leading-relaxed mb-8">
						A couple of days ago I was testing the load time of all the react websites I helped build for my previous company, and it came out to be under 1
						second each. I was surprised and quite happy to learn that. So your question might be how it happened. I believe it happened because of the three
						things -
					</p>
					<h4 class="text-gray-800 text-lg font-normal leading-relaxed mt-4">- Use of NextJS - The React Framework for Production</h4>
					<h4 class="text-gray-800 text-lg font-normal leading-relaxed mt-4">- Vercel’s Global Infrastructure</h4>
					<h4 class="text-gray-800 text-lg font-normal leading-relaxed mt-4">- Optimisations from our side</h4>
				</section>
				<section>
					<h2 class="text-gray-800 text-[22px] sm:text-[24px] font-medium leading-relaxed my-8 mb-6">How NextJS helped decrease our website load time?</h2>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3 mb-8">
						Next.js is a flexible React framework for production that gave us an excellent developer experience with a number of performance optimisations baked
						in. The main idea behind the framework is to ensure applications start and remain as performant as possible by having these capabilities included by
						default -
					</p>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">1. Image Optimisation</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						The Next.js Image component includes a variety of built-in performance optimisations to helped us achieve good Core Web Vitals. These scores are an
						important measurement of user experience on any website, and are factored into Google’s search rankings. Some of the optimisations built into the
						Image component are -
					</p>
					<h4 class="text-gray-800 text-lg font-normal leading-relaxed mt-4">
						- Improved Performance -&nbsp;<span class="text-gray-700 text-lg font-light leading-relaxed"
							>Always serve correctly sized image for each device, using modern formats.</span
						>
					</h4>
					<h4 class="text-gray-800 text-lg font-normal leading-relaxed mt-3">
						- Visual Stability -&nbsp;<span class="text-gray-700 text-lg font-light leading-relaxed">Prevent Cumulative Layout Shift automatically.</span>
					</h4>
					<h4 class="text-gray-800 text-lg font-normal leading-relaxed mt-3">
						- Faster Page Loads -&nbsp;<span class="text-gray-700 text-lg font-light leading-relaxed"
							>Images are only loaded when they enter the viewport, with optional placeholders.</span
						>
					</h4>
					<h4 class="text-gray-800 text-lg font-normal leading-relaxed mt-3">
						- Asset Flexibility -&nbsp;<span class="text-gray-700 text-lg font-light leading-relaxed"
							>On-demand image resizing, even for images stored on remote servers.</span
						>
					</h4>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">2. Font Optimisation</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						Next.js has built-in web font optimisation. By default, Next.js will automatically inline font CSS at build time, eliminating an extra round trip to
						fetch font declarations. This results in improvements to First Contentful Paint (FCP) and Largest Contentful Paint (LCP).
					</p>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">3. Code-splitting and Bundling</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						NextJS’ optimized bundle splitting algorithm is created by the Google Chrome team which improves the application’s initial load time by only loading
						the code required to run that page.
					</p>
				</section>
				<section>
					<h2 class="text-gray-800 text-[22px] sm:text-[24px] font-medium leading-relaxed my-8">How Vercel helped decrease our website load time?</h2>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">1. Dynamic Edge Caching</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						The Vercel Edge Network caches our content at the edge in order to serve data to our users as fast as possible. Static files are automatically
						cached at the edge after the first request. Static files are cached for up to 31 days. If a file is unchanged, it can persist across deployments, as
						their hash caches static files. However, the cache is effectively invalidated when we redeploy, so it always serve the latest version.
					</p>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">2. Asset Compression</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						To save bandwidth and make our application or site faster, the Vercel Edge Network implements two compression algorithms gzip and brotli. While gzip
						has been around for quite some time, brotli is a relatively new compression algorithm built by Google that best serves text compression. brotli also
						has an advantage over gzip since it uses a dictionary of common keywords on both the client and server-side, which gives a better compression ratio.
					</p>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">3. Global Edge Network</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						The Vercel Edge Network sits in-between the internet and our Vercel deployments. This type of network topology is sometimes called a Content
						Delivery Network or CDN. The Vercel Edge Network has many responsibilities, but most importantly, it is responsible for routing requests to the
						correct Serverless Function or Static File output of our Builds. The Vercel Edge Network is a CDN with the ability to execute functions at the edge.
					</p>
				</section>
				<section>
					<h2 class="text-gray-800 text-[22px] sm:text-[24px] font-medium leading-relaxed my-8">Other things that helped decrease our website load time?</h2>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed">1. Tailwind CSS</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						Tailwind CSS is basically a utility-first CSS framework for rapidly building custom user interfaces. It is a highly customizable, low-level CSS
						framework that gives us all of the building blocks we need to build bespoke designs without any annoying opinionated styles we have to fight to
						override.
					</p>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						Tailwind automatically removes all unused CSS when building for production, which means our final CSS bundle is the smallest it could possibly be.
						In fact, most Tailwind projects ship less than 10kB of CSS to the client.
					</p>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">2. Link Preloading</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						When someone visits our website, their browser loads all the resources on that web page in a certain order, which we can see from the Network tab in
						Chrome developer tools or in a performance testing tool like GTmetrix or WebPageTest. By default, web browsers decide how to load these resources
						based on the order that they’re declared in our site’s HTML, which isn’t always optimal from a performance and/or user experience perspective.
					</p>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						With preload, we can force browsers to load certain resources early on, like fonts. This gives us more control over how our site loads, which, when
						implemented properly, let us improve our site’s performance.
					</p>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">3. Efficient File Formats</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						Using WOFF2 which is a font format that provides, on average, a 30% reduction in file size, thus helping web fonts load more quickly in compatible
						browsers. Similarly WebP which is a modern image format that provides superior lossless and lossy compression for images on the web. Using WebP,
						webmasters and web developers can create smaller, richer images that make the web faster.
					</p>
					<h3 class="text-gray-800 text-xl font-normal leading-relaxed mt-8">4. Faster API Response Time</h3>
					<p class="text-gray-700 text-lg font-light leading-relaxed mt-3">
						Using a performant backend infrastructure with a datacenter located in India (where our customers are) saved us a lot of time in latency resulting
						our API response time starting from 51ms. In&nbsp;<span class="underline"
							><a
								target="_blank"
								rel="noreferrer"
								href="https://hashnode.com/post/how-we-brought-down-the-response-time-of-hashnode-to-less-100ms-cjrhrfe9l015484s2gwvndvd8"
								>this</a
							></span
						>&nbsp; post, Sandeep Panda explains how he brought down Hashnode’s API response time under 100ms using multiple optimisation techniques.
					</p>
				</section>
			</div>
		</div>
	</div>
</div>
